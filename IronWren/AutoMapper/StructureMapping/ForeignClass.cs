using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace IronWren.AutoMapper.StructureMapping
{
    /// <summary>
    /// Contains the bindings generated by the AutoMapper.
    /// </summary>
    internal sealed class ForeignClass
    {
        private readonly StringBuilder source = new StringBuilder();

        /// <summary>
        /// Gets the <see cref="ForeignFunction"/>s that are part of the class.
        /// <para/>
        /// Includes everything (methods, properties, fields).
        /// </summary>
        public Dictionary<string, ForeignFunction> Functions { get; } = new Dictionary<string, ForeignFunction>();

        /// <summary>
        /// Gets the TypeInfo of the Type that this ForeignClass targets.
        /// </summary>
        public TypeInfo Target { get; }

        public ForeignClass(TypeInfo target)
        {
            if (target.IsAbstract && !target.IsSealed)
                throw new ArgumentException("The target class can't be abstract!", nameof(target));

            if (target.IsGenericType && target.GetGenericTypeDefinition() == target.AsType())
                throw new ArgumentException("The target class can't be an undefined generic!", nameof(target));

            Target = target;

            foreach (var field in target.DeclaredFields.Where(field => field.IsPublic))
            {
                Functions.Add(field.GetSignature(PropertyType.Get), new ForeignField(field, PropertyType.Get));

                if (!field.IsLiteral && !field.IsInitOnly)
                    Functions.Add(field.GetSignature(PropertyType.Set), new ForeignField(field, PropertyType.Set));
            }

            foreach (var property in target.DeclaredProperties.Where(property => property.GetMethod.IsPublic || property.SetMethod.IsPublic))
            {
                if (property.GetMethod.IsPublic)
                    Functions.Add(property.GetSignature(PropertyType.Get), new ForeignProperty(property, PropertyType.Get));

                if (property.SetMethod.IsPublic)
                    Functions.Add(property.GetSignature(PropertyType.Set), new ForeignProperty(property, PropertyType.Set));
            }

            foreach (var constructor in target.DeclaredConstructors.Where(constructor => constructor.IsPublic))
                Functions.Add(constructor.GetSignature(), new ForeignConstructor(constructor));

            // Generics?
            foreach (var method in target.DeclaredMethods.Where(method => method.IsPublic))
            {
                var signature = method.GetSignature();
                if (!Functions.ContainsKey(signature))
                    Functions.Add(method.GetSignature(), new ForeignMethod(method));
            }
        }

        public string GetSource()
        {
            // TODO: Inheritance?
            source.AppendLine($"foreign class {Target.Name} {{");

            foreach (var foreignMethod in Functions.Values)
                source.AppendLine(foreignMethod.GetSource());

            source.AppendLine("}");

            return source.ToString();
        }
    }
}