using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;
using System.Text;

namespace IronWren.AutoMapper.StructureMapping
{
    /// <summary>
    /// Contains the bindings generated by the AutoMapper.
    /// </summary>
    internal sealed class ForeignClass
    {
        private readonly ConstructorInfo constructor;
        private readonly Dictionary<string, ForeignFunction> functions = new Dictionary<string, ForeignFunction>();
        private readonly StringBuilder source = new StringBuilder();

        /// <summary>
        /// Gets the <see cref="ForeignFunction"/>s that are part of the class.
        /// <para/>
        /// Includes everything (methods, properties, fields).
        /// </summary>
        public ReadOnlyDictionary<string, ForeignFunction> Functions { get; }

        /// <summary>
        /// Gets the TypeInfo of the Type that this ForeignClass targets.
        /// </summary>
        public TypeInfo Target { get; }

        public ForeignClass(TypeInfo target)
        {
            Functions = new ReadOnlyDictionary<string, ForeignFunction>(functions);

            if (target.IsAbstract && !target.IsSealed)
                throw new ArgumentException("The target type can't be abstract!", nameof(target));

            if (target.IsGenericType && target.GetGenericTypeDefinition() == target.AsType())
                throw new ArgumentException("The target type can't be an undefined generic!", nameof(target));

            Target = target;

            constructor = target.DeclaredConstructors.SingleOrDefault(ctor =>
                {
                    if (!ctor.IsPublic)
                        return false;

                    var parameters = ctor.GetParameters();
                    return parameters.Length == 1 && parameters[0].ParameterType == typeof(WrenVM);
                });

            if (constructor != null)
            {
                var wrenConstructors = constructor.GetCustomAttributes<WrenConstructorAttribute>().ToArray();

                if (wrenConstructors.Length == 0)
                {
                    var signature = Signature.MakeConstructor(WrenConstructorAttribute.DefaultArguments.Length);

                    functions.Add(signature, new ForeignConstructor(constructor, WrenConstructorAttribute.DefaultArguments));
                }
                else
                    foreach (var wrenConstructor in wrenConstructors)
                    {
                        var signature = Signature.MakeConstructor(wrenConstructor.Arguments.Length);

                        if (functions.ContainsKey(signature))
                            throw new Exception("Can't have multiple constructors with the same signature!");

                        functions.Add(signature, new ForeignConstructor(constructor, wrenConstructor.Arguments));
                    }
            }

            // Generics?
            foreach (var method in target.DeclaredMethods.Where(method =>
                {
                    if (!method.IsPublic || method.ReturnType != typeof(void))
                        return false;

                    var parameters = method.GetParameters();
                    return parameters.Length == 1 && parameters[0].ParameterType == typeof(WrenVM);
                }))
            {
                var propertyAttribute = method.GetCustomAttribute<WrenPropertyAttribute>();
                if (propertyAttribute != null)
                {
                    var signature = Signature.MakeProperty(propertyAttribute.Type, propertyAttribute.Name);

                    if (functions.ContainsKey(signature))
                        throw new Exception("Can't have multiple properties with the same signature!");

                    functions.Add(signature, new ForeignProperty(method, propertyAttribute));

                    continue;
                }

                var indexerAttribute = method.GetCustomAttribute<WrenIndexerAttribute>();
                if (indexerAttribute != null)
                {
                    var signature = Signature.MakeIndexer(indexerAttribute.Type, indexerAttribute.Name, indexerAttribute.Arguments.Length);

                    if (functions.ContainsKey(signature))
                        throw new Exception("Can't have multiple indexers with the same signature!");

                    functions.Add(signature, new ForeignIndexer(method, indexerAttribute));

                    continue;
                }

                var methodAttributes = method.GetCustomAttributes<WrenMethodAttribute>();
                foreach (var methodAttribute in methodAttributes)
                {
                    var signature = Signature.MakeMethod(methodAttribute.Name, methodAttribute.Arguments.Length);

                    if (functions.ContainsKey(signature))
                        throw new Exception("Can't have multiple methods with the same signature!");

                    functions.Add(signature, new ForeignMethod(method, methodAttribute));
                }
            }
        }

        public string GetSource()
        {
            // TODO: Inheritance?
            source.AppendLine($"foreign class {Target.Name} {{");

            foreach (var foreignFunction in Functions.Values)
                source.AppendLine(foreignFunction.GetSource());

            source.AppendLine("}");

            return source.ToString();
        }

        internal WrenForeignClassMethods Bind()
        {
            var foreignClassMethods = new WrenForeignClassMethods();

            foreignClassMethods.Allocate = construct;
            // TODO: Finalizer?

            return foreignClassMethods;
        }

        private void construct(WrenVM vm)
        {
            var instance = constructor.Invoke(new[] { vm });

            vm.SetSlotNewForeign(0, instance);
        }

        private ForeignConstructor selectConstructor(WrenVM vm)
        {
            var parameterCount = vm.GetSlotCount() - 1;
            var signature = $"new({string.Join(",", Enumerable.Repeat("_", parameterCount))})";

            if (!functions.ContainsKey(signature))
                throw new ArgumentOutOfRangeException("parameterCount", "No constructor with that number of arguments found!");

            IEnumerable<ForeignConstructor> possibleConstructors = null; //functions[signature].Cast<ForeignConstructor>();

            if (possibleConstructors.Count() == 1)
                return possibleConstructors.First();

            for (var i = 0; i < parameterCount; ++i)
            {
                // i + 1 because the first slot is the target/return value
                switch (vm.GetSlotType(i + 1))
                {
                    case WrenType.Bool:
                        possibleConstructors = possibleConstructors.Where(c => c.Constructor.GetParameters()[i].ParameterType == typeof(bool));
                        break;

                    case WrenType.Number:
                        possibleConstructors = possibleConstructors.Where(c =>
                        {
                            var pType = c.Constructor.GetParameters()[i].ParameterType;

                            return pType == typeof(byte) || pType == typeof(sbyte)
                            || pType == typeof(ushort) || pType == typeof(short)
                            || pType == typeof(uint) || pType == typeof(int)
                            || pType == typeof(ulong) || pType == typeof(long)
                            || pType == typeof(float) || pType == typeof(double);
                        });
                        break;

                    case WrenType.List:
                        possibleConstructors = possibleConstructors.Where(c => c.Constructor.GetParameters()[i].ParameterType.GetTypeInfo()
                            .ImplementedInterfaces.Select(t => t.GetTypeInfo())
                            .Any(intf => intf.IsGenericType && intf.GetGenericTypeDefinition() == typeof(IEnumerable<>)));
                        break;

                    case WrenType.String:
                        possibleConstructors = possibleConstructors.Where(c =>
                        {
                            var pType = c.Constructor.GetParameters()[i].ParameterType;

                            return pType == typeof(string) || pType == typeof(byte[]);
                        });
                        break;

                    default:
                        continue;
                }

                if (possibleConstructors.Count() == 1)
                    break;
            }

            if (possibleConstructors.Count() == 0)
                throw new Exception("No matching constructor found!");

            return possibleConstructors.First();
        }
    }
}