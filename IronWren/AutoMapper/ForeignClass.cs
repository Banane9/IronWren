using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;

namespace IronWren.AutoMapper
{
    /// <summary>
    /// Contains the bindings generated by the AutoMapper.
    /// </summary>
    internal sealed class ForeignClass
    {
        private static readonly ParameterExpression finalizerObjParam = Expression.Parameter(typeof(object));

        private static readonly MethodInfo genericGetSlotForeign = typeof(WrenVM).GetTypeInfo()
                    .GetDeclaredMethods("GetSlotForeign").Single(method => method.IsGenericMethod);

        private static readonly ConstantExpression slot = Expression.Constant(0);
        private static readonly ParameterExpression vmParam = Expression.Parameter(typeof(WrenVM));

        private readonly ConstructorInfo constructor;
        private readonly WrenFinalizer finalize;

        private readonly Dictionary<string, WrenForeignMethod> functions = new Dictionary<string, WrenForeignMethod>();

        private readonly MethodCallExpression getSlotForeign;

        private readonly string source;

        private readonly TypeInfo target;

        /// <summary>
        /// Gets the <see cref="WrenForeignMethod"/>s that are part of the class.
        /// <para/>
        /// Includes everything (methods, properties, indexers).
        /// </summary>
        public ReadOnlyDictionary<string, WrenForeignMethod> Functions { get; }

        /// <summary>
        /// Gets the name of the class on the Wren side.
        /// </summary>
        public string Name { get; }

        public ForeignClass(Type target)
        {
            this.target = target.GetTypeInfo();

            if (this.target.IsAbstract && !this.target.IsSealed)
                throw new ArgumentException("The target type can't be abstract!", nameof(target));

            if (this.target.IsGenericType && this.target.GetGenericTypeDefinition() == this.target.AsType())
                throw new ArgumentException("The target type can't be an undefined generic!", nameof(target));

            getSlotForeign = Expression.Call(vmParam, genericGetSlotForeign.MakeGenericMethod(target), slot);

            Functions = new ReadOnlyDictionary<string, WrenForeignMethod>(functions);

            var sourceBuilder = new StringBuilder();

            var classAttribute = this.target.GetCustomAttribute<WrenClassAttribute>();
            Name = classAttribute?.Name ?? this.target.Name;

            sourceBuilder.AppendLine($"foreign class {Name} {{");

            constructor = makeConstructors(sourceBuilder);
            finalize = makeFinalize();

            // Generics?
            foreach (var method in this.target.DeclaredMethods.Where(method =>
                {
                    if (!method.IsPublic || method.ReturnType != typeof(void))
                        return false;

                    var parameters = method.GetParameters();
                    return parameters.Length == 1 && parameters[0].ParameterType == typeof(WrenVM);
                }))
            {
                var propertyAttribute = method.GetCustomAttribute<WrenPropertyAttribute>();
                if (propertyAttribute != null)
                {
                    var signature = Signature.MakeProperty(propertyAttribute.Type, propertyAttribute.Name);

                    if (functions.ContainsKey(signature))
                        throw new SignatureExistsException(signature, target);

                    functions.Add(signature, getInvoker(method));
                    sourceBuilder.AppendLine(Definition.MakeProperty(method));

                    continue;
                }

                var indexerAttribute = method.GetCustomAttribute<WrenIndexerAttribute>();
                if (indexerAttribute != null)
                {
                    var signature = Signature.MakeIndexer(indexerAttribute.Type, indexerAttribute.Arguments.Length);

                    if (functions.ContainsKey(signature))
                        throw new SignatureExistsException(signature, target);

                    functions.Add(signature, getInvoker(method));
                    sourceBuilder.AppendLine(Definition.MakeIndexer(method));

                    continue;
                }

                var methodAttributes = method.GetCustomAttributes<WrenMethodAttribute>();
                foreach (var methodAttribute in methodAttributes)
                {
                    var signature = Signature.MakeMethod(methodAttribute.Name, methodAttribute.Arguments.Length);

                    if (functions.ContainsKey(signature))
                        throw new SignatureExistsException(signature, target);

                    functions.Add(signature, getInvoker(method));
                    sourceBuilder.AppendLine(Definition.MakeMethod(method));
                }
            }

            sourceBuilder.AppendLine("}");

            source = sourceBuilder.ToString();
        }

        public string GetSource()
        {
            return source;
        }

        internal WrenForeignClassMethods Bind()
        {
            return new WrenForeignClassMethods
            {
                Allocate = construct,
                Finalize = finalize
            };
        }

        private void construct(WrenVM vm)
        {
            var instance = constructor.Invoke(new[] { vm });

            vm.SetSlotNewForeign(0, instance);
        }

        private WrenForeignMethod getInvoker(MethodInfo method)
        {
            if (method.IsStatic)
                return (WrenForeignMethod)method.CreateDelegate(typeof(WrenForeignMethod));

            // vm => vm.GetSlotForeign<TTarget>(0).[method](vm)
            return Expression.Lambda<WrenForeignMethod>(
                Expression.Call(getSlotForeign, method, vmParam),
                vmParam).Compile();
        }

        private ConstructorInfo makeConstructors(StringBuilder sourceBuilder)
        {
            var constructor = target.DeclaredConstructors.SingleOrDefault(ctor =>
            {
                if (!ctor.IsPublic)
                    return false;

                var parameters = ctor.GetParameters();

                return parameters.Length == 1 && parameters[0].ParameterType == typeof(WrenVM);
            });

            if (constructor != null)
            {
                var wrenConstructors = constructor.GetCustomAttributes<WrenConstructorAttribute>().ToArray();

                if (wrenConstructors.Length == 0)
                    sourceBuilder.AppendLine($"{Definition.MakeConstructor()} {{ }}");
                else
                    foreach (var wrenConstructor in wrenConstructors)
                        sourceBuilder.AppendLine($"{Definition.MakeConstructor(wrenConstructor.Arguments)} {{ }}");
            }

            return constructor;
        }

        private WrenFinalizer makeFinalize()
        {
            var finalizeMethod = target.AsType().GetRuntimeMethods()
                .SingleOrDefault(method => method.GetCustomAttribute<WrenFinalizerAttribute>() != null);

            if (finalizeMethod == null)
                return null;

            if (finalizeMethod.ReturnType != typeof(void) || finalizeMethod.GetParameters().Length != 0)
                throw new InvalidSignatureException(finalizeMethod.Name, target.AsType(), typeof(WrenFinalizerAttribute));

            // finalizeObj => ((TTarget)finalizeObj).[finalize]()
            return Expression.Lambda<WrenFinalizer>(
                Expression.Call(Expression.Convert(finalizerObjParam, target.AsType()), finalizeMethod),
                finalizerObjParam).Compile();
        }
    }
}